# A set that can be drawn from quickly
#
# Copyright (C) 2021 Simon Dobson
#
# This file is part of epydemic, epidemic network simulations in Python.
#
# epydemic is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# epydemic is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with epydemic. If not, see <http://www.gnu.org/licenses/gpl.html>.

from epydemic import Element
from typing import Any, Set, List, Tuple, Iterable
import numpy


class Bitstream(object):
    '''An infinite stream of random bits. The bits are generated from a
    random number generated by the generator in `numpy` and consumed bitwise.

    :param size: (optional) size of the entropy pool in words'''

    # Underlying types
    Dtype = numpy.int64                        #: Type ufor elements of the entropy pool.
    DtypeSize = 63                             #: Bits per element (excluding sign).

    def __init__(self, size : int =100):
        self._rng = numpy.random.default_rng()

        self._pool: List[int] = []                      # entropy pool
        self._size = size                               # size of the pool
        self._max : int = 2 ** self.DtypeSize -1        # maximum value of an entry in the pool
        self._element : int = 0                         # current element from the pool
        self._nelement : int = 0                        # index of current element
        self._index : int = 0                           # current bit within the element
        self._mask : int = 1                            # bit-mask

        self._refill()

    def _refill(self):
        '''Re-fill the entropy pool. This creates another batch of random numbers
        to be drawn from.'''
        self._pool = self._rng.integers(self._max, size=self._size, dtype=self.Dtype)
        self._nElement = 0
        self._element = int(self._pool[0])

    def __iter__(self) -> Iterable[int]:
        '''Return an iterator of bits.

        :retruns: an iterator'''
        return self

    def __next__(self) -> int:
        '''Return a random bit.

        :returns: a random bit'''
        bit = (self._element & self._mask) >> self._index
        self._index += 1
        self._mask <<= 1
        if self._index == self.DtypeSize:
            self._nElement += 1
            if self._nElement == self._size:
                self._refill()
            else:
                self._element = int(self._pool[self._nElement])
            self._index = 0
            self._mask = 1
        return bit

    def integer(self, n : int):
        '''Return a random integer. The integer is constructed using bits
        from the generator.

        :param n: the limit
        :returns: a random integer on the range [0, n]'''
        v = 0
        m = 1
        while True:
            m <<= 1
            if m >= n:
                return v
            else:
                v <<= 1
                v += next(self)


class DrawableSet(object):
    '''A set that can be drawn from randomly.

    The implementation uses an balanced (red-black) binary search
    tree. Addition, deletion, and containment testing are all
    :math:`O(\log n)` average time complexity, as is the :meth:`draw`
    method that selects a uniformly random element.

    We don't implement the whole of the standard set interface as we
    don't need it for the current application. Possibly we ought to,
    just to be future-proof.

    :param d: (optional) the data at the tree node (defaults to None)
    :param p: (optional) the parent node (defaults to None)

    '''

    Bitstream = Bitstream()   #: A random bit stream generator.

    def __init__(self, d: Element = None, p: 'DrawableSet' = None):
        self._red: bool = False             # red or black (root is always black)
        self._left: 'DrawableSet' = None    # left sub-tree
        self._right: 'DrawableSet' = None   # right sub-tree
        self._parent: 'DrawableSet' = p     # parent nodes
        self._data: Element = d             # value at this node
        self._height: int = 0               # height of sub-tree rooted at this node

    def _add(self, e: Element) -> int:
        '''Private method to add a value to the tree.

        :param e: the element to addCompartment:
        :returns: the new height of the tree'''
        if self._data is None:
            # we're the root, store here
            self._data = e
            return 0
        elif e == self._data:
            # value is already in the set, return
            return self._height
        elif e < self._data:
            # add in left sub-tree
            if self._left is None:
                # no left sub-tree, create a new node and attach it
                self._left = DrawableSet(e, self)
                self._height = max(self._height, 1)
            else:
                # descend into right sub-tree, updating our height
                self._height = max(self._height, self._left._add(e) + 1)
        else:
            # add in right sub-tree
            if self._right is None:
                # no right sub-tree, create a new node and attach it
                self._right = DrawableSet(e, self)
                self._height = max(self._height, 1)
            else:
                # descend into right sub-tree, updating our height
                self._height = max(self._height, self._right._add(e) + 1)
        return self._height

    def add(self, e: Element):
        '''Add an element to the set. This is a no-op if the element is already
        in the set.

        :param e: the element to add'''
        self._add(e)

    def _find(self, e: Element) -> 'DrawableSet':
        '''Private method to search for an element.

        :param e: the element
        :returns: the node holding the element or None'''
        if e == self._data:
            # element found, return
            return self
        elif e < self._data:
            # element should be in left sub-tree
            if self._left is None:
                return None
            else:
                return self._left._find(e)
        else:
            # element should be in right sub-tree
            if self._right is None:
                return None
            else:
                return self._right._find(e)

    def __contains__(self, e: Element) -> bool:
        '''Check whether the given element is a member of ther set.

        :param e: the element
        :returns: True if the element is in the set'''
        if self._data is None:
            # we've the (empty) root
            return False
        else:
            return self._find(e) is not None

    def empty(self) -> bool:
        '''Test if the set is empty.

        :returns: True if the set is empty'''
        return self._data is None

    def __len__(self) -> int:
        '''Return the size of the set.

        :returns: the size of the set'''
        if self._data is None:
            # we're the (empty) root
            return 0
        else:
            s = 1
            if self._left is not None:
                s += len(self._left)
            if self._right is not None:
                s += len(self._right)
            return s

    def elements(self) -> List[Element]:
        '''Returns all the elements in the set as a list.

        :returns: a list of element'''
        if self._data is None:
            # we're the (empty) root
            return []
        else:
            # perform an in-order traverse of the tree
            es = []
            if self._left is not None:
                es.extend(self._left.elements())
            es.append(self._data)
            if self._right is not None:
                es.extend(self._right.elements())
            return es

    def __iter__(self) -> Iterable[Element]:
        '''Returns an iterator over the elements of the set.

        :returns: an iterator'''
        return iter(self.elements())

    def __eq__(self, s : 'DrawableSet') -> bool:
        '''Tests for item-wise equality.

        :param s: the other set
        :returns: True if all the elements match'''
        if len(s) != len(self):
            return False
        a = self.iter()
        b = s.iter()
        for i in a:
            if i != next(b):
                return False
        return True

    def leftmost(self) -> 'DrawableSet':
        if self._left is None:
            return self
        else:
            return self._left.leftmost()

    def rightmost(self) -> 'DrawableSet':
        if self._right is None:
            return self
        else:
            return self._right.rightmost()

    def nextElement(self) -> 'DrawableSet':
        '''Return the the "least disruptive element" to swap with
        when discarding a branch node. This is selected randomly
        from the left or right sub-tree.

        :returns: the node to swap with'''
        if self._left is None:
            if self._right is None:
                return None
            else:
                return self._right.leftmost()
        elif self._right is None:
            return self._left.rightmost()
        else:
            b = next(self.Bitstream)
            if b == 0:
                return self._left.rightmost()
            else:
                return self._right.leftmost()

    def _discard(self, e: Element) -> Tuple['DrawableSet', int]:
        '''Provate methiod to discard an element from the tree.

        :param e: the element
        :returns: the replacement node and its height'''
        if self._data is None:
            # we're the (empty) root node, there's nothing to be discarded
            return (None, -1)

        elif e == self._data:
            # we hold the data, find the least disruptive element to swap us with
            # this will always be taken from the taller sub-tree
            n = self.nextElement()
            if n is None:
                # we're a leaf, we can simply be deleted
                self._data = None   # this handles the case where we're the last (root) element
                return (None, -1)
            else:
                # grab the data at the chosen nodes
                d = n._data

                # recursively delete the data from the sub-tree
                if d < self._data:
                    (self._left, h) = self._left._discard(d)
                    if self._right is None:
                        self._height = h + 1
                    else:
                        self._height = max(self._right._height, h) + 1
                else:
                    (self._right, h) = self._right._discard(d)
                    if self._left is None:
                        self._height = h + 1
                    else:
                        self._height = max(self._left._height, h) + 1

                # replace our data with that from the chosen node
                self._data = d

        elif e < self._data:
            if self._left is not None:
                (self._left, h) = self._left._discard(e)
                if self._right is None:
                    self._height = h + 1
                else:
                    self._height = max(self._right._height, h) + 1
        else:
            if self._right is not None:
                (self._right, h) = self._right._discard(e)
                if self._left is None:
                    self._height = h + 1
                else:
                    self._height = max(self._left._height, h) + 1

        # return our new size
        return (self, self._height)

    def discard(self, e: Element):
        '''Discard the given element from the set. If the element
        isn't in the set, this is a no-op.

        :param e: the element'''
        self._discard(e)

    def draw(self) -> Element:
        '''Draw an element from the set at random.

        :returns: a random element, or none if the set is empty'''
        pathlength = self.Bitstream.integer(self._height)
        n = self
        bits = iter(self.Bitstream)
        for _ in range(pathlength):
            b = next(bits)
            if b == 0:
                n = n._left
            else:
                n = n._right
            if n is None:
                n = self
        return n._data
